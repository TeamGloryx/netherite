use crate::abs::{FlattenMapResult, FlattenResult, Parenthesized, ProcMacro};
use proc_macro2::{Literal, TokenStream, TokenTree};
use quote::{format_ident, quote, ToTokens};
use std::collections::HashMap;
use std::fmt::{Debug, Formatter};
use syn::{
    ext::IdentExt, parse::Parse, parse::ParseStream, parse::Parser, punctuated::Punctuated,
    spanned::Spanned, Attribute, Data, DeriveInput, Error, Expr, ExprLit, Ident, Lit, Token, Type,
    Variant,
};

pub(crate) struct EnumFields;

impl ProcMacro for EnumFields {
    fn parse(self, input: TokenStream) -> syn::Result<TokenStream> {
        let input = Parser::parse2(DeriveInput::parse, input)?;

        /*
        let generated = quote! {
            /// CODE GENERATED BY rscraft-procmacro
            /// DO NOT TRY TO UNDERSTAND THIS, JUST USE THE METHODS
            /// NAMED AFTER THE ENUM FIELDS!
        };
         */

        let iname = input.ident.clone();
        if let Data::Enum(en) = &input.data {
            let mut attrs = HashMap::new();

            for variant in &en.variants {
                let a: Vec<_> = variant
                    .attrs
                    .iter()
                    .filter_map(|Attribute { tokens, path, .. }| {
                        if ["enum_field", "ef"]
                            .contains(&path.segments.first()?.ident.unraw().to_string().as_str())
                        {
                            let field = Parser::parse2(
                                Parenthesized::<Punctuated<EnumField, Token![,]>>::parse,
                                tokens.clone(),
                            )
                            .map(|a| a.0);

                            Some(field)
                        } else {
                            None
                        }
                    })
                    .flatten_result()?
                    .into_iter()
                    .fold(
                        Punctuated::new(),
                        |mut p: Punctuated<EnumField, Token![,]>, a| {
                            p.extend(a);
                            p
                        },
                    )
                    .into_iter()
                    .collect();

                attrs.insert(&variant.ident, a);
            }

            if let [awk] = &input
                .attrs
                .iter()
                .filter(|a| {
                    let a = a.path.segments.first();
                    if a.is_none() {
                        return false;
                    }
                    a.unwrap().ident.unraw() == "enum_field"
                })
                .flatten_map(|a| {
                    Parser::parse2(
                        Parenthesized::<Punctuated<EnumFieldType, Token![,]>>::parse,
                        a.tokens.clone(),
                    )
                    .map(|a| a.0)
                })?
                .collect::<Vec<_>>()[..]
            {
                let fields = awk.into_iter().map(|a| (&a.0, &a.1, &a.2));

                let variant_name = awk.into_iter().find(|t| t.3.is_some());

                let into_field = fields
                    .clone()
                    .find(|(_, _, d)| d.is_some())
                    .map(|(i, t, _)| {
                        let into_name = format_ident!("Into{}", iname);

                        let matchers = attrs
                            .iter()
                            .map(|(id, vec)| {
                                (
                                    vec.iter()
                                        .find(|f| i.eq(&f.0))
                                        .unwrap(),
                                    *id,
                                )
                            })
                            .map(|(EnumField(_, _, _, e), id)| {
                                if let Expr::Lit(ExprLit { lit: Lit::Str(lit), .. }) = e {
                                    quote!(format!(#lit) => Ok(#iname::#id),)
                                } else {
                                    quote!(#e => Ok(#iname::#id),)
                                }
                            })
                            .collect::<TokenStream>();

                        quote! {
                            #[doc(hidden)]
                            #[derive(::serde::Serialize, ::serde::Deserialize)]
                            #[serde(transparent)]
                            pub struct #into_name(#t);

                            impl Into<#into_name> for #iname {
                                fn into(self) -> #into_name {
                                    #into_name(self.#i())
                                }
                            }

                            impl TryFrom<#into_name> for #iname {
                                type Error = String;

                                fn try_from(i: #into_name) -> Result<Self, Self::Error> {
                                    match i.0 {
                                        #matchers
                                        val => Err(format!("value {} not found in enum values", val)),
                                    }
                                }
                            }
                        }
                    })
                    .unwrap_or(TokenStream::new());

                let struct_fields = fields
                    .clone()
                    .map(|(id, ty, _)| quote! { pub #id: #ty, })
                    .collect::<TokenStream>();

                let field_accessors = fields
                    .map(|(a, b, _)| quote! { pub fn #a(&self) -> #b { self.#a() }})
                    .collect::<TokenStream>();

                let fields_struct_name =
                    Ident::new(format!("{}EnumFields", iname).as_str(), input.span());

                let fields_struct = quote! {
                    #[doc(hidden)]
                    pub struct #fields_struct_name {
                        #struct_fields
                    }
                };

                let variants: TokenStream = attrs
                    .into_iter()
                    .map(|(ident, fields)| {
                        let mut fields = fields
                            .into_iter()
                            .map(|field| {
                                let id = field.ident();
                                let val = field.value();
                                if let Expr::Lit(ExprLit {
                                    lit: Lit::Str(lit), ..
                                }) = val
                                {
                                    quote!(#id: format!(#lit))
                                } else {
                                    quote!(#id: #val)
                                }
                            })
                            .collect::<Vec<TokenStream>>();

                        if let Some(EnumFieldType(var_id, ..)) = variant_name {
                            let ident_str = TokenTree::Literal(Literal::string(&ident.to_string()));
                            fields.push(quote!(#var_id: String::from(#ident_str)))
                        }

                        quote! {
                            #iname::#ident => #fields_struct_name {
                                #(#fields),*
                            },
                        }
                    })
                    .collect();

                Ok(quote! {
                    #fields_struct
                    #[doc(hidden)]
                    impl #iname {
                        #field_accessors

                        #[doc(hidden)]
                        pub fn fields(&self) -> #fields_struct_name {
                            match self {
                                #variants
                                _ => unreachable!()
                            }
                        }
                    }

                    #into_field
                })
            } else {
                Err(Error::new(input.span(), "no variants :("))
            }
        } else {
            Err(Error::new(input.span(), "expected enum"))
        }
    }
}

mod kw {
    use syn::custom_keyword;

    custom_keyword!(delegate);
    custom_keyword!(variant_name);
}

pub(crate) struct EnumFieldType(
    pub Ident,
    pub Type,
    pub Option<kw::delegate>,
    pub Option<kw::variant_name>,
);

impl Parse for EnumFieldType {
    fn parse(input: ParseStream) -> syn::Result<Self> {
        let la = input.lookahead1();

        if la.peek(kw::variant_name) {
            let variant_name: kw::variant_name = input.parse()?;
            let delegate: Option<kw::delegate> = if input.peek(kw::delegate) {
                Some(input.parse()?)
            } else {
                None
            };
            let ident = input.parse()?;
            let _ = input.parse::<Token![:]>()?;
            Ok(EnumFieldType(
                ident,
                input.parse()?,
                delegate,
                Some(variant_name),
            ))
        } else if la.peek(kw::delegate) {
            let delegate: kw::delegate = input.parse()?;
            let ident = input.parse()?;
            let _ = input.parse::<Token![:]>()?;
            Ok(EnumFieldType(ident, input.parse()?, Some(delegate), None))
        } else if la.peek(Ident) {
            let ident = input.parse()?;
            let _ = input.parse::<Token![:]>()?;
            Ok(EnumFieldType(ident, input.parse()?, None, None))
        } else {
            Err(la.error())
        }
    }
}

pub(crate) struct EnumField(Ident, Option<Type>, Token![=], Expr);

impl Debug for EnumField {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        writeln!(
            f,
            "EnumField({}, {}, {})",
            self.0,
            self.2.to_token_stream(),
            self.3.to_token_stream()
        )
    }
}

#[allow(dead_code)]
impl EnumField {
    fn typ(&self) -> &Option<Type> {
        &self.1
    }

    fn ident(&self) -> &Ident {
        &self.0
    }

    fn eq_token(&self) -> Token![=] {
        self.2
    }

    fn value(&self) -> &Expr {
        &self.3
    }
}

impl Parse for EnumField {
    fn parse(input: ParseStream) -> syn::Result<Self> {
        let la = input.lookahead1();

        if la.peek(Ident) {
            Ok(EnumField(
                input.parse()?,
                None,
                input.parse()?,
                input.parse()?,
            ))
        } else {
            Err(la.error())
        }
    }
}

pub(crate) struct EnumValues;

impl ProcMacro for EnumValues {
    fn parse(self, input: TokenStream) -> syn::Result<TokenStream> {
        let input = Parser::parse2(DeriveInput::parse, input)?;

        if let Data::Enum(en) = input.data {
            let enum_name = input.ident;
            let variants: Vec<_> = en
                .variants
                .into_iter()
                .map(|Variant { ident, .. }| quote!(#enum_name::#ident))
                .collect();
            let values_num = TokenTree::Literal(Literal::usize_unsuffixed(variants.len()));

            Ok(quote! {
                impl #enum_name {
                    pub const VALUES: [#enum_name; #values_num] = [#(#variants),*];
                }
            })
        } else {
            Err(Error::new(input.span(), ""))
        }
    }
}
